"""
UBOS Blueprint: Project Management System

Philosophy: Blueprint Thinking + Systems Over Willpower
Strategic Purpose: Track complex multi-agent workflows and generated code
System Design: Hierarchical project organization with workflow tracking
Feedback Loops: Monitor project progress, agent performance, code quality
Environmental Support: File system storage with JSON metadata
"""

import json
import os
from pathlib import Path
from datetime import datetime, timezone
from typing import Dict, Any, List, Optional
from dataclasses import dataclass, asdict
import uuid

@dataclass
class ProjectMetadata:
    project_id: str
    name: str
    description: str
    created_at: str
    status: str  # "planning", "active", "completed", "paused"
    agents_involved: List[str]
    constitutional_requirements: List[str]
    estimated_completion: Optional[str] = None

@dataclass  
class WorkflowExecution:
    execution_id: str
    project_id: str
    workflow_name: str
    agents_sequence: List[str]
    started_at: str
    completed_at: Optional[str] = None
    status: str = "running"  # "running", "completed", "failed", "paused"
    results: Dict[str, Any] = None
    constitutional_compliance: float = 0.0

@dataclass
class CodeGenerationRecord:
    generation_id: str
    project_id: str
    specification: str
    generated_code: str
    model_used: str
    constitutional_score: float
    generated_at: str
    file_path: Optional[str] = None

class UBOSProjectManager:
    def __init__(self, base_path: str = "UBOS/ProjectManager"):
        self.base_path = Path(base_path)
        self.base_path.mkdir(parents=True, exist_ok=True)

        # Create subdirectories
        (self.base_path / "projects").mkdir(exist_ok=True)
        (self.base_path / "workflows").mkdir(exist_ok=True)
        (self.base_path / "tests").mkdir(exist_ok=True)
        (self.base_path / "code_generation").mkdir(exist_ok=True)
        (self.base_path / "performance").mkdir(exist_ok=True)

    def create_project(self, name: str, description: str, 
                      constitutional_requirements: List[str]) -> str:
        """Create a new UBOS project"""

        project_id = f"ubos-{uuid.uuid4().hex[:8]}"
        project_metadata = ProjectMetadata(
            project_id=project_id,
            name=name,
            description=description,
            created_at=datetime.now(timezone.utc).isoformat(),
            status="planning",
            agents_involved=[],
            constitutional_requirements=constitutional_requirements
        )

        # Create project directory
        project_dir = self.base_path / "projects" / project_id
        project_dir.mkdir(parents=True, exist_ok=True)

        # Save metadata
        with open(project_dir / "metadata.json", 'w') as f:
            json.dump(asdict(project_metadata), f, indent=2)

        # Create project structure
        (project_dir / "specifications").mkdir(exist_ok=True)
        (project_dir / "generated_code").mkdir(exist_ok=True)
        (project_dir / "tests").mkdir(exist_ok=True)
        (project_dir / "documentation").mkdir(exist_ok=True)
        (project_dir / "workflows").mkdir(exist_ok=True)

        print(f"Created project: {project_id} - {name}")
        return project_id

    def start_workflow_execution(self, project_id: str, workflow_name: str,
                                agents_sequence: List[str]) -> str:
        """Start tracking a workflow execution"""

        execution_id = f"exec-{uuid.uuid4().hex[:8]}"
        execution = WorkflowExecution(
            execution_id=execution_id,
            project_id=project_id,
            workflow_name=workflow_name,
            agents_sequence=agents_sequence,
            started_at=datetime.now(timezone.utc).isoformat()
        )

        # Save execution record
        execution_file = self.base_path / "workflows" / f"{execution_id}.json"
        with open(execution_file, 'w') as f:
            json.dump(asdict(execution), f, indent=2)

        print(f"Started workflow execution: {execution_id}")
        return execution_id

    def record_code_generation(self, project_id: str, specification: str,
                             generated_code: str, model_used: str,
                             constitutional_score: float) -> str:
        """Record generated code with constitutional metadata"""

        generation_id = f"gen-{uuid.uuid4().hex[:8]}"

        # Save generated code to file
        project_dir = self.base_path / "projects" / project_id / "generated_code"
        code_file = project_dir / f"{generation_id}.py"  # or appropriate extension

        with open(code_file, 'w') as f:
            f.write(f'"""\nGenerated by UBOS Constitutional AI\nGeneration ID: {generation_id}\nConstitutional Score: {constitutional_score}\n"""\n\n')
            f.write(generated_code)

        # Create generation record
        record = CodeGenerationRecord(
            generation_id=generation_id,
            project_id=project_id,
            specification=specification,
            generated_code=generated_code,
            model_used=model_used,
            constitutional_score=constitutional_score,
            generated_at=datetime.now(timezone.utc).isoformat(),
            file_path=str(code_file)
        )

        # Save generation metadata
        gen_file = self.base_path / "code_generation" / f"{generation_id}.json"
        with open(gen_file, 'w') as f:
            json.dump(asdict(record), f, indent=2)

        print(f"Recorded code generation: {generation_id}")
        return generation_id

    def get_project_status(self, project_id: str) -> Dict[str, Any]:
        """Get comprehensive project status"""

        project_dir = self.base_path / "projects" / project_id
        if not project_dir.exists():
            return {"error": "Project not found"}

        # Load metadata
        with open(project_dir / "metadata.json", 'r') as f:
            metadata = json.load(f)

        # Count generated files
        code_files = list((project_dir / "generated_code").glob("*.py"))
        test_files = list((project_dir / "tests").glob("*.py"))

        # Get workflow executions
        workflow_files = list(self.base_path.glob(f"workflows/*{project_id}*.json"))

        return {
            "metadata": metadata,
            "generated_code_files": len(code_files),
            "test_files": len(test_files),
            "workflow_executions": len(workflow_files),
            "last_activity": self._get_last_activity(project_id)
        }

    def _get_last_activity(self, project_id: str) -> Optional[str]:
        """Get timestamp of last project activity"""
        # Implementation would check file modification times
        return datetime.now(timezone.utc).isoformat()
