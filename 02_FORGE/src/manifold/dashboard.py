"""The Steampunk Hi-Fi Manifold Dashboard.

This script provides a real-time, text-based visualization of the metrics
generated by the Pattern Engine, rendered with a steampunk aesthetic.

It can be run in two modes:
1. Live Mode (default): Captures and displays a single, live pulse.
2. Playback Mode (--playback): Queries and replays the last 5 saved pulses.
"""

import time
import os
import sqlite3
import sys

# Assuming the script is run from 02_FORGE with PYTHONPATH=src
from pattern_engine.engine import PatternEngine
from oracle_bridge.bridge import OracleBridge
from pattern_engine.schema import PatternMetrics

DB_FILE = "/srv/janus/02_FORGE/src/manifold/manifold_metrics.db"

def render_gauge(label: str, value: float, max_value: float = 1.0) -> str:
    """Renders a single ASCII art gauge."""
    percentage = value / max_value
    fill_width = int(percentage * 20)
    fill = '█' * fill_width
    empty = '░' * (20 - fill_width)
    return f"  {label:<20} [{fill}{empty}] {value:.2f}"

def render_manifold(metrics: PatternMetrics, message: str):
    """Renders the full dashboard to the console."""
    os.system('clear')
    print("┌─────────────────── THE HARMONIC MANIFOLD ────────────────────┐")
    print("│  STATUS: ONLINE         VESSEL: BALAUR         SIGNAL: LIVE   │")
    print("├─────────────────────────────────────────────────────────────┤")
    print("│                                                             │")
    print("│ ╔═══════════════════ PATTERN ENGINE METRICS ══════════════╗ │")
    print("│ ║                                                         ║ │")
    print(f"│ ║{render_gauge('Entropy Index', metrics.entropy_index)}      ║ │")
    print(f"│ ║{render_gauge('Resonance Density', metrics.resonance_density)}  ║ │")
    print(f"│ ║{render_gauge('Cohesion Flux', metrics.cohesion_flux)}        ║ │")
    print(f"│ ║{render_gauge('Signal Integrity', metrics.signal_integrity)}   ║ │")
    print("│ ║                                                         ║ │")
    print("│ ╚═══════════════════════════════════════════════════════════╝ │")
    print("│                                                             │")
    print(f"│  Pulse Capture Time: {metrics.timestamp} (UTC)                      │")
    print("└─────────────────────────────────────────────────────────────┘")
    print(f"\n{message}")

def save_metrics_to_db(metrics: PatternMetrics):
    """Saves a PatternMetrics object to the SQLite database."""
    conn = sqlite3.connect(DB_FILE)
    cursor = conn.cursor()
    
    cursor.execute("""INSERT OR IGNORE INTO metrics (timestamp, entropy_index, resonance_density, cohesion_flux, signal_integrity)
                     VALUES (?, ?, ?, ?, ?)""", 
                   (metrics.timestamp, metrics.entropy_index, metrics.resonance_density, metrics.cohesion_flux, metrics.signal_integrity))
    
    conn.commit()
    conn.close()

def run_live_capture():
    """Runs a single live pulse capture, renders it, and saves it."""
    print("--- [Live Capture Mode] ---")
    bridge = OracleBridge()
    engine = PatternEngine()
    
    symbolic_params = {"type": "Ω-Symbolic", "expression": "fourier_transform(data)"}
    job_id = bridge.submit_class_omega_calc(symbolic_params)
    job_result = bridge.get_job_status(job_id)
    
    if job_result and job_result.result:
        timestamp = int(time.time())
        final_metrics = engine.analyze_stream(job_result.result, timestamp)
        
        save_metrics_to_db(final_metrics)
        render_manifold(final_metrics, f"...Metrics from pulse {timestamp} saved to local DB...")
    else:
        print("Error: Could not process pulse capture.")

def playback_history():
    """Queries and displays the last 5 metrics from the database."""
    print("--- [Playback Mode] ---")
    conn = sqlite3.connect(DB_FILE)
    cursor = conn.cursor()
    
    cursor.execute("SELECT * FROM metrics ORDER BY timestamp DESC LIMIT 5")
    rows = cursor.fetchall()
    conn.close()

    if not rows:
        print("No historical data found to play back.")
        return

    print(f"Found {len(rows)} historical pulses. Playing back now...")
    time.sleep(2)

    for row in reversed(rows): # Play in chronological order
        metrics = PatternMetrics(
            timestamp=row[0],
            entropy_index=row[1],
            resonance_density=row[2],
            cohesion_flux=row[3],
            signal_integrity=row[4]
        )
        render_manifold(metrics, f"...Playing back historical pulse from {row[0]}...")
        time.sleep(1.5)

    print("\nPlayback complete.")

def main():
    """Main function to select mode based on command-line arguments."""
    if "--playback" in sys.argv:
        playback_history()
    else:
        run_live_capture()

if __name__ == "__main__":
    main()
